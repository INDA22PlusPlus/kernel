use crate::graph::planar::*;
use crate::graph::surface::*;
use crate::graph::utils::*;
use crate::math::vec2::*;
use crate::tooling::qemu_io::*;
use crate::tooling::serial::inb;
use crate::tooling::serial::outb;
use crate::tooling::serial::outw;

use core::cmp::max;
use core::cmp::min;
use core::ptr::read_volatile;

/*
Represents the write layer of the graphics component
Contains an additional buffer(plane_buffer) that is not the video memory,
thus we essentially get double buffering. This additional buffer is then by its
entirety written to the video memory(present).

https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#intro
http://www.osdever.net/FreeVGA/vga/vgareg.htm
http://www.osdever.net/FreeVGA/vga/colorreg.htm
https://qbmikehawk.neocities.org/articles/palette/

*/

#[rustfmt::skip]
const FONT_MAPPING: [u8; 2304] = [
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
	0x06,0x00,0x60,0x0F,0x00,0xF0,0x0F,0x00,0xF0,0x0F,0x00,0x60,0x06,0x00,0x60,0x00,0x00,0x00,0x06,0x00,0x60,0x00,0x00,0x00, // !
	0x00,0x00,0x00,0x19,0x81,0x98,0x19,0x81,0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "
	0x00,0x00,0x66,0x06,0x60,0x66,0x3F,0xF0,0xCC,0x0C,0xC1,0x98,0x19,0x87,0xFC,0x33,0x03,0x30,0x33,0x00,0x00,0x00,0x00,0x00, // #
	0x06,0x00,0x60,0x1F,0x83,0xFC,0x36,0x03,0x60,0x3F,0x81,0xFC,0x06,0xC0,0x6C,0x3F,0xC1,0xF8,0x06,0x00,0x60,0x00,0x00,0x00, // $
	0x00,0x00,0x00,0x00,0x13,0x83,0x38,0x73,0x8E,0x01,0xC0,0x38,0x07,0x00,0xE0,0x1C,0x03,0x8E,0x70,0xE6,0x0E,0x00,0x00,0x00, // %
	0x00,0x00,0x70,0x0D,0x81,0x98,0x19,0x81,0xB0,0x0E,0x01,0xE0,0x3E,0x03,0x36,0x33,0xC3,0x18,0x3B,0xC1,0xE6,0x00,0x00,0x00, // &
	0x0E,0x00,0xE0,0x0E,0x00,0x60,0x06,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
	0x03,0x80,0x60,0x0E,0x00,0xC0,0x1C,0x01,0xC0,0x1C,0x01,0xC0,0x1C,0x01,0xC0,0x0C,0x00,0xE0,0x06,0x00,0x38,0x00,0x00,0x00, // (
	0x1C,0x00,0x60,0x07,0x00,0x30,0x03,0x80,0x38,0x03,0x80,0x38,0x03,0x80,0x38,0x03,0x00,0x70,0x06,0x01,0xC0,0x00,0x00,0x00, // )
	0x00,0x00,0x00,0x00,0x03,0x6C,0x36,0xC1,0xF8,0x0F,0x03,0xFC,0x0F,0x01,0xF8,0x36,0xC3,0x6C,0x00,0x00,0x00,0x00,0x00,0x00, // *
	0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x60,0x06,0x03,0xFC,0x3F,0xC0,0x60,0x06,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00, // +
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0E,0x00,0xE0,0x06,0x00,0xC0, // ,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // -
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0E,0x00,0xE0,0x00,0x00,0x00, // .
	0x00,0x00,0x01,0x00,0x30,0x07,0x00,0xE0,0x1C,0x03,0x80,0x70,0x0E,0x01,0xC0,0x38,0x07,0x00,0x60,0x00,0x00,0x00,0x00,0x00, // /
	0x0F,0x83,0xFE,0x30,0x66,0x07,0x60,0xF6,0x1B,0x63,0x36,0x63,0x6C,0x37,0x83,0x70,0x33,0x06,0x3F,0xE0,0xF8,0x00,0x00,0x00, // 0
	0x03,0x00,0x70,0x1F,0x01,0xF0,0x03,0x00,0x30,0x03,0x00,0x30,0x03,0x00,0x30,0x03,0x00,0x30,0x1F,0xE1,0xFE,0x00,0x00,0x00, // 1
	0x1F,0xC3,0xFE,0x70,0x76,0x03,0x60,0x70,0x0E,0x01,0xC0,0x38,0x07,0x00,0xE0,0x1C,0x03,0x80,0x7F,0xF7,0xFF,0x00,0x00,0x00, // 2
	0x1F,0xC3,0xFE,0x70,0x76,0x03,0x00,0x30,0x07,0x0F,0xE0,0xFC,0x00,0x60,0x03,0x60,0x37,0x07,0x3F,0xE1,0xFC,0x00,0x00,0x00, // 3
	0x01,0xC0,0x3C,0x07,0xC0,0xEC,0x1C,0xC3,0x8C,0x70,0xC6,0x0C,0x7F,0xF7,0xFF,0x00,0xC0,0x0C,0x00,0xC0,0x0C,0x00,0x00,0x00, // 4
	0x7F,0xF7,0xFF,0x60,0x06,0x00,0x60,0x07,0xFC,0x3F,0xE0,0x07,0x00,0x30,0x03,0x60,0x37,0x07,0x3F,0xE1,0xFC,0x00,0x00,0x00, // 5
	0x03,0xC0,0x7C,0x0E,0x01,0xC0,0x38,0x03,0x00,0x7F,0xC7,0xFE,0x70,0x76,0x03,0x60,0x37,0x07,0x3F,0xE1,0xFC,0x00,0x00,0x00, // 6
	0x7F,0xF7,0xFF,0x00,0x60,0x06,0x00,0xC0,0x0C,0x01,0x80,0x18,0x03,0x00,0x30,0x06,0x00,0x60,0x0C,0x00,0xC0,0x00,0x00,0x00, // 7
	0x0F,0x81,0xFC,0x38,0xE3,0x06,0x30,0x63,0x8E,0x1F,0xC3,0xFE,0x70,0x76,0x03,0x60,0x37,0x07,0x3F,0xE1,0xFC,0x00,0x00,0x00, // 8
	0x1F,0xC3,0xFE,0x70,0x76,0x03,0x60,0x37,0x07,0x3F,0xF1,0xFF,0x00,0x60,0x0E,0x01,0xC0,0x38,0x1F,0x01,0xE0,0x00,0x00,0x00, // 9
	0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0xE0,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0xE0,0x0E,0x00,0x00,0x00,0x00,0x00, // :
	0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0xE0,0x0E,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0xE0,0x0E,0x00,0x60,0x06,0x00,0xC0, // ;
	0x00,0xC0,0x1C,0x03,0x80,0x70,0x0E,0x01,0xC0,0x38,0x03,0x80,0x1C,0x00,0xE0,0x07,0x00,0x38,0x01,0xC0,0x0C,0x00,0x00,0x00, // <
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFE,0x3F,0xE0,0x00,0x00,0x03,0xFE,0x3F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // =
	0x30,0x03,0x80,0x1C,0x00,0xE0,0x07,0x00,0x38,0x01,0xC0,0x1C,0x03,0x80,0x70,0x0E,0x01,0xC0,0x38,0x03,0x00,0x00,0x00,0x00, // >
	0x1F,0x83,0xFC,0x70,0xE6,0x06,0x60,0xE0,0x1C,0x03,0x80,0x70,0x06,0x00,0x60,0x06,0x00,0x00,0x06,0x00,0x60,0x00,0x00,0x00, // ?
	0x1F,0xC3,0xFE,0x30,0x66,0x7B,0x6F,0xB6,0xDB,0x6D,0xB6,0xDB,0x6D,0xB6,0xFE,0x67,0xC7,0x00,0x3F,0xC0,0xFC,0x00,0x00,0x00, // @
	0x06,0x00,0x60,0x0F,0x00,0xF0,0x0F,0x01,0x98,0x19,0x81,0x98,0x30,0xC3,0xFC,0x3F,0xC6,0x06,0x60,0x66,0x06,0x00,0x00,0x00, // A
	0x7F,0x07,0xF8,0x61,0xC6,0x0C,0x60,0xC6,0x1C,0x7F,0x87,0xFC,0x60,0xE6,0x06,0x60,0x66,0x0E,0x7F,0xC7,0xF8,0x00,0x00,0x00, // B
	0x0F,0x81,0xFC,0x38,0xE3,0x06,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x30,0x63,0x8E,0x1F,0xC0,0xF8,0x00,0x00,0x00, // C
	0x7F,0x07,0xF8,0x61,0xC6,0x0C,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0xC6,0x1C,0x7F,0x87,0xF0,0x00,0x00,0x00, // D
	0x7F,0xE7,0xFE,0x60,0x06,0x00,0x60,0x06,0x00,0x7F,0x87,0xF8,0x60,0x06,0x00,0x60,0x06,0x00,0x7F,0xE7,0xFE,0x00,0x00,0x00, // E
	0x7F,0xE7,0xFE,0x60,0x06,0x00,0x60,0x06,0x00,0x7F,0x87,0xF8,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x00,0x00,0x00, // F
	0x0F,0xC1,0xFE,0x38,0x63,0x00,0x60,0x06,0x00,0x63,0xE6,0x3E,0x60,0x66,0x06,0x30,0x63,0x86,0x1F,0xE0,0xFE,0x00,0x00,0x00, // G
	0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x7F,0xE7,0xFE,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x00,0x00,0x00, // H
	0x1F,0x81,0xF8,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x1F,0x81,0xF8,0x00,0x00,0x00, // I
	0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x66,0x06,0x60,0x67,0x0C,0x3F,0xC1,0xF8,0x00,0x00,0x00, // J
	0x60,0x66,0x0E,0x61,0xC6,0x38,0x67,0x06,0xE0,0x7C,0x07,0xC0,0x6E,0x06,0x70,0x63,0x86,0x1C,0x60,0xE6,0x06,0x00,0x00,0x00, // K
	0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x7F,0xE7,0xFE,0x00,0x00,0x00, // L
	0x60,0x67,0x0E,0x70,0xE7,0x9E,0x79,0xE6,0xF6,0x6F,0x66,0x66,0x66,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x00,0x00,0x00, // M
	0x60,0x67,0x06,0x70,0x67,0x86,0x6C,0x66,0xC6,0x66,0x66,0x66,0x63,0x66,0x36,0x61,0xE6,0x0E,0x60,0xE6,0x06,0x00,0x00,0x00, // N
	0x0F,0x01,0xF8,0x39,0xC3,0x0C,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x30,0xC3,0x9C,0x1F,0x80,0xF0,0x00,0x00,0x00, // O
	0x7F,0x87,0xFC,0x60,0xE6,0x06,0x60,0x66,0x06,0x60,0xE7,0xFC,0x7F,0x86,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x00,0x00,0x00, // P
	0x0F,0x01,0xF8,0x39,0xC3,0x0C,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x36,0x33,0xC3,0x9C,0x1F,0xE0,0xF6,0x00,0x00,0x00, // Q
	0x7F,0x87,0xFC,0x60,0xE6,0x06,0x60,0x66,0x06,0x60,0xE7,0xFC,0x7F,0x86,0x70,0x63,0x86,0x1C,0x60,0xE6,0x06,0x00,0x00,0x00, // R
	0x1F,0x83,0xFC,0x70,0xE6,0x06,0x60,0x07,0x00,0x3F,0x81,0xFC,0x00,0xE0,0x06,0x60,0x67,0x0E,0x3F,0xC1,0xF8,0x00,0x00,0x00, // S
	0x3F,0xC3,0xFC,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x00,0x00,0x00, // T
	0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x63,0x0C,0x3F,0xC1,0xF8,0x00,0x00,0x00, // U
	0x60,0x66,0x06,0x60,0x63,0x0C,0x30,0xC3,0x0C,0x19,0x81,0x98,0x19,0x80,0xF0,0x0F,0x00,0xF0,0x06,0x00,0x60,0x00,0x00,0x00, // V
	0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x66,0x66,0x66,0x66,0xF6,0x79,0xE7,0x0E,0x70,0xE6,0x06,0x00,0x00,0x00, // W
	0x60,0x66,0x06,0x30,0xC3,0x0C,0x19,0x80,0xF0,0x06,0x00,0x60,0x0F,0x01,0x98,0x30,0xC3,0x0C,0x60,0x66,0x06,0x00,0x00,0x00, // X
	0x60,0x66,0x06,0x30,0xC3,0x0C,0x19,0x81,0x98,0x0F,0x00,0xF0,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x00,0x00,0x00, // Y
	0x7F,0xE7,0xFE,0x00,0xC0,0x0C,0x01,0x80,0x30,0x06,0x00,0x60,0x0C,0x01,0x80,0x30,0x03,0x00,0x7F,0xE7,0xFE,0x00,0x00,0x00, // Z
	0x1F,0x81,0xF8,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x1F,0x81,0xF8,0x00,0x00,0x00, // [
	0x00,0x04,0x00,0x60,0x07,0x00,0x38,0x01,0xC0,0x0E,0x00,0x70,0x03,0x80,0x1C,0x00,0xE0,0x07,0x00,0x30,0x00,0x00,0x00,0x00, // \
	0x1F,0x81,0xF8,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x1F,0x81,0xF8,0x00,0x00,0x00, // ]
	0x02,0x00,0x70,0x0F,0x81,0xDC,0x38,0xE7,0x07,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ^
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xF7,0xFF, // _
	0x00,0x00,0x70,0x07,0x00,0x70,0x06,0x00,0x60,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // `
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFC,0x3F,0xE0,0x06,0x1F,0xE3,0xFE,0x60,0x66,0x06,0x7F,0xE3,0xFE,0x00,0x00,0x00, // a
	0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0xF8,0x7F,0xC7,0x0E,0x60,0x66,0x06,0x60,0x66,0x0E,0x7F,0xC7,0xF8,0x00,0x00,0x00, // b
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x3F,0xC7,0x06,0x60,0x06,0x00,0x60,0x07,0x06,0x3F,0xC1,0xF8,0x00,0x00,0x00, // c
	0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x61,0xF6,0x3F,0xE7,0x1E,0x60,0x66,0x06,0x60,0x67,0x06,0x3F,0xE1,0xFE,0x00,0x00,0x00, // d
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x3F,0xC7,0x06,0x7F,0xE7,0xFC,0x60,0x07,0x00,0x3F,0xC1,0xF8,0x00,0x00,0x00, // e
	0x07,0x80,0xF8,0x1C,0x01,0x80,0x18,0x01,0x80,0x7F,0x07,0xF0,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x00,0x00,0x00, // f
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFE,0x3F,0xE7,0x06,0x60,0x67,0x0E,0x3F,0xE1,0xF6,0x00,0x60,0x0E,0x3F,0xC3,0xF8, // g
	0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0xF0,0x7F,0x87,0x1C,0x60,0xC6,0x0C,0x60,0xC6,0x0C,0x60,0xC6,0x0C,0x00,0x00,0x00, // h
	0x00,0x00,0x00,0x06,0x00,0x60,0x00,0x00,0xE0,0x0E,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x1F,0x81,0xF8,0x00,0x00,0x00, // i
	0x00,0x00,0x00,0x01,0x80,0x18,0x00,0x00,0x38,0x03,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x81,0x98,0x1F,0x80,0xF0, // j
	0x30,0x03,0x00,0x30,0x03,0x00,0x30,0x03,0x18,0x33,0x83,0x70,0x3E,0x03,0xE0,0x37,0x03,0x38,0x31,0xC3,0x0C,0x00,0x00,0x00, // k
	0x0E,0x00,0xE0,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x1F,0x81,0xF8,0x00,0x00,0x00, // l
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x98,0x7F,0xC7,0xFE,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00, // m
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x3F,0xC3,0x0E,0x30,0x63,0x06,0x30,0x63,0x06,0x30,0x63,0x06,0x00,0x00,0x00, // n
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x3F,0xC7,0x0E,0x60,0x66,0x06,0x60,0x67,0x0E,0x3F,0xC1,0xF8,0x00,0x00,0x00, // o
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x7F,0xC6,0x0E,0x60,0x66,0x06,0x70,0xE7,0xFC,0x6F,0x86,0x00,0x60,0x06,0x00, // p
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFE,0x3F,0xE7,0x06,0x60,0x66,0x06,0x70,0xE3,0xFE,0x1F,0x60,0x06,0x00,0x60,0x06, // q
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x7C,0x3F,0xE3,0x86,0x30,0x03,0x00,0x30,0x03,0x00,0x30,0x03,0x00,0x00,0x00,0x00, // r
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF0,0x7F,0x86,0x00,0x7F,0x03,0xF8,0x01,0x80,0x18,0x7F,0x83,0xF0,0x00,0x00,0x00, // s
	0x00,0x01,0x80,0x18,0x01,0x80,0x18,0x07,0xF0,0x7F,0x01,0x80,0x18,0x01,0x80,0x18,0x01,0x80,0x1F,0x80,0xF8,0x00,0x00,0x00, // t
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x60,0x66,0x06,0x60,0x66,0x06,0x60,0x67,0x0E,0x3F,0xE1,0xF6,0x00,0x00,0x00, // u
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x60,0x63,0x0C,0x30,0xC1,0x98,0x19,0x80,0xF0,0x0F,0x00,0x60,0x00,0x00,0x00, // v
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6F,0x63,0xFC,0x39,0xC1,0x08,0x00,0x00,0x00, // w
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x0C,0x71,0xC3,0xB8,0x1F,0x00,0xE0,0x1F,0x03,0xB8,0x71,0xC6,0x0C,0x00,0x00,0x00, // x
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x30,0xC1,0x98,0x19,0x80,0xF0,0x0F,0x00,0x60,0x06,0x00,0xC0,0x0C,0x01,0x80, // y
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x7F,0x80,0x30,0x06,0x00,0xC0,0x18,0x03,0x00,0x7F,0xC7,0xFC,0x00,0x00,0x00, // z
	0x03,0xC0,0x7C,0x0E,0x00,0xC0,0x0C,0x00,0xC0,0x1C,0x03,0x80,0x1C,0x00,0xC0,0x0C,0x00,0xC0,0x0E,0x00,0x7C,0x03,0xC0,0x00, // {
	0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x06,0x00,0x60,0x00,0x00,0x00, // |
	0x3C,0x03,0xE0,0x07,0x00,0x30,0x03,0x00,0x30,0x03,0x80,0x1C,0x03,0x80,0x30,0x03,0x00,0x30,0x07,0x03,0xE0,0x3C,0x00,0x00, // }
	0x00,0x00,0x00,0x1C,0x63,0x6C,0x63,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ~
	0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xF0,0x19,0x83,0x0C,0x60,0x66,0x06,0x7F,0xE7,0xFE,0x00,0x00,0x00,0x00,0x00,0x00 // 
];

pub fn get_font_entry(a: char) -> usize {
    return (a as usize - 32);
}

pub struct VGA_planar_writer {
    video_buffer: &'static mut [u8],
    plane_buffer: [u8; VGA_planar_writer::VIDEO_MEM_EXT_SZ],
    pub palette: ColorPalette,
    plane: Planar,
}

impl VGA_planar_writer {
    //Bit masks for accessing individual bits in each u8 of each bitplane
    const BIT_MAPPING: [u8; 8] = [0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1];

    //Resolution stuff
    const SCAN_LN_SZ: usize = 80;
    const SCAN_LN_CNT: usize = 480;
    const COL_CNT: usize = 640;

    //Video memory adress
    const VIDEO_MEM_BASE: *mut u8 = 0xA0000 as *mut u8;

    //Size of the video memory, represents one bitplane
    const VIDEO_MEM_SZ: usize = VGA_planar_writer::SCAN_LN_CNT * VGA_planar_writer::SCAN_LN_SZ;

    //Additional buffer(planar buffer) memory adress
    const VIDEO_MEM_EXT_BASE: *mut u8 = 0x1e8480 as *mut u8;

    //The size of this extra buffer, corresponding to the size of 4 bitplanes
    const VIDEO_MEM_EXT_SZ: usize =
        VGA_planar_writer::SCAN_LN_CNT * VGA_planar_writer::SCAN_LN_SZ * 4;

    const PLANE_SZ: usize = VGA_planar_writer::SCAN_LN_CNT * VGA_planar_writer::SCAN_LN_SZ;

    pub fn new() -> Self {
        ColorPalette::read_vga_dac_state();

        let mut A = unsafe {
            VGA_planar_writer {
                video_buffer: core::slice::from_raw_parts_mut(
                    VGA_planar_writer::VIDEO_MEM_BASE,
                    VGA_planar_writer::VIDEO_MEM_SZ,
                ),

                plane_buffer: [0; VGA_planar_writer::VIDEO_MEM_EXT_SZ],

                palette: ColorPalette::new(),
                plane: Planar::new(),
            }
        };
        VGA_planar_writer::setup_registers();
        A.reset_ext_memory();
        return A;
    }

    pub fn write_pixel(&mut self, row: usize, col: usize, color: ColorCode) {
        let color_bits: [u8; 4] = [
            (color as u8) & 1,
            (color as u8) & 2,
            (color as u8) & 4,
            (color as u8) & 8,
        ];
        let bit_pos = col % 8;
        let buffer_idx = (VGA_planar_writer::SCAN_LN_SZ * row + col / 8) as usize;
        let mask = VGA_planar_writer::BIT_MAPPING[bit_pos as usize];

        for i in 0..4 {
            let bit_value = color_bits[i];
            if (bit_value > 0) {
                self.plane_buffer[buffer_idx + i * VGA_planar_writer::PLANE_SZ] |= mask;
            } else {
                self.plane_buffer[buffer_idx + i * VGA_planar_writer::PLANE_SZ] &= (!mask);
            }
        }
    }

    pub fn setup_registers() {
        //Data rotate register, no rotation, no modification
        outb(0x3ce, 0x03);
        outb(0x3cf, 0x00);

        //Setting up final bitmask
        outb(0x3ce, 0x08);
        outb(0x3cf, 0xff);

        //Setting "Enable Set/Register"
        outb(0x3ce, 0x01);
        outb(0x3cf, 0x0);
    }

    pub fn set_write_mode(mode: u8) {
        assert!(mode < 4);
        //Write mode register, picking write mode 0, read mode 0

        let stashed = inb(0x3cf);
        outb(0x3ce, 0x05);
        outb(0x3cf, (stashed & 0xfc) | mode);
    }

    pub fn write_pixel_2(&mut self, row: usize, col: usize, color: ColorCode) {
        VGA_planar_writer::setup_registers();
        //VGA_planar_writer::set_write_mode(0, color);

        let stashed_adress_reg = inb(0x3c4);
        outb(0x3c4, 0x02);

        let stashed_data_reg = inb(0x3c5);
        outb(0x3c5, stashed_data_reg & (color as u8));
        outb(0x3c4, stashed_adress_reg);

        //Data rotate register, no rotation, OR
        outb(0x3ce, 0x03);
        outb(0x3cf, 0x10);

        //outb(0x3ce, )

        let bit_pos = col % 8;
        let buffer_idx = (VGA_planar_writer::SCAN_LN_SZ * row + col / 8) as usize;
        let mask = VGA_planar_writer::BIT_MAPPING[bit_pos as usize];
        //qemu_print_hex(mask as u32);

        self.plane_buffer[buffer_idx + 1 * VGA_planar_writer::PLANE_SZ] |= mask;
        self.video_buffer[buffer_idx] =
            self.plane_buffer[buffer_idx + 1 * VGA_planar_writer::PLANE_SZ]; //self.video_buffer[buffer_idx] | mask;
    }

    pub fn clear_screen_2(&mut self) {
        //Set/Reset register, all 1
        outb(0x3ce, 0x0);
        outb(0x3cf, 0xff);

        ////Enable Set/Reset register
        outb(0x3ce, 0x01);
        outb(0x3cf, 1);

        //Pick all planes
        outb(0x3c4, 0x02);
        outb(0x3c4, 0xf);

        //Do not rotate, and use AND
        outb(0x3ce, 0x03);
        outb(0x3cf, 0x8);

        //Write mode register
        outb(0x3ce, 0x05);
        outb(0x3cf, 0x0);

        for i in 0..VGA_planar_writer::VIDEO_MEM_SZ {
            self.video_buffer[i] = 0;
            //let row = (i * 8) / 80;
            //self.write_pixel_2(i/80, i%, color)
        }
    }

    fn col_clip(&mut self, x: i32) -> usize {
        return x.clamp(0, VGA_planar_writer::COL_CNT as i32 - 1) as usize;
    }
    fn row_clip(&mut self, x: i32) -> usize {
        return x.clamp(0, VGA_planar_writer::SCAN_LN_CNT as i32 - 1) as usize;
    }

    pub fn write_circle(&mut self, mid: (usize, usize), radius: usize, color: ColorCode) {
        let min_x = self.col_clip(mid.1 as i32 - radius as i32);
        let max_x = self.col_clip(mid.1 as i32 + radius as i32);

        let min_y = self.row_clip(mid.0 as i32 - radius as i32);
        let max_y = self.row_clip(mid.0 as i32 + radius as i32);

        for i in min_y..max_y {
            for j in min_x..max_x {
                let d_squared = (mid.0 as i32 - i as i32).pow(2) + (mid.1 as i32 - j as i32).pow(2);
                if (d_squared < (radius as i32).pow(2)) {
                    self.write_pixel(i as usize, j as usize, color);
                }
            }
        }
    }

    pub fn write_rect(
        &mut self,
        mid: (usize, usize),
        width: usize,
        height: usize,
        color: ColorCode,
    ) {
        let min_x: usize = self.col_clip(mid.1 as i32 - (width / 2) as i32);
        let max_x: usize = self.col_clip(mid.1 as i32 + ((width + 1) / 2) as i32);

        let min_y: usize = self.row_clip(mid.0 as i32 - (height / 2) as i32);
        let max_y: usize = self.row_clip(mid.0 as i32 + ((height + 1) / 2) as i32);

        for i in min_y..max_y {
            for j in min_x..max_x {
                self.write_pixel(i, j, color);
            }
        }
    }

    pub fn write_surface(&mut self, surface: &Surface) {
        let surface_offset = surface.get_origin();
        for i in 0..surface.get_height() {
            for j in 0..surface.get_width() {
                let cell_color: ColorCode = surface.get_cell(i, j);
                self.write_pixel(i + surface_offset.x, j + surface_offset.y, cell_color);
            }
        }
    }

    //pub fn write_line(dir: Vec2<f32, origin: Vec2, length: f32) {}

    fn reset_ext_memory(&mut self) {
        for i in 0..VGA_planar_writer::VIDEO_MEM_EXT_SZ {
            self.plane_buffer[i] = 0;
        }
    }

    fn reset_video_memory(&mut self) {
        for i in 0..VGA_planar_writer::VIDEO_MEM_SZ {
            //self.video_buffer[i] = 0;
            let row = (i * 8) / 80;
            //self.write_pixel_2(i/80, i%, color)
        }
    }

    fn replicate_plane(&mut self, planar: usize) {
        let offset: usize = planar * VGA_planar_writer::PLANE_SZ;
        for i in 0..VGA_planar_writer::PLANE_SZ {
            //self.video_buffer[i] = self.plane_buffer[i + offset];
        }
    }

    fn replicate(&mut self) {
        VGA_planar_writer::set_write_mode(0);

        for k in 0..4 {
            outb(0x3c4, 0x02);
            outb(0x3c5, 1 << k);

            unsafe {
                let ptr = self
                    .plane_buffer
                    .as_ptr()
                    .add(k * VGA_planar_writer::PLANE_SZ);
                self.video_buffer
                    .copy_from_slice(core::slice::from_raw_parts(
                        ptr,
                        VGA_planar_writer::PLANE_SZ,
                    ));
            }
        }
    }

    pub fn set_pixel(&mut self, row: usize, col: usize, color: u8) {
        let pixel_mask = 0x80 >> (col & 0x07);
        let buffer_idx = (VGA_planar_writer::SCAN_LN_SZ * row + col / 8) as usize;
        outb(0x3ce, 0x08);
        outb(0x3cf, pixel_mask);
        unsafe {
            let a = self.video_buffer[buffer_idx];
        }
        self.video_buffer[buffer_idx] = color;
    }

    pub fn print_plane(&mut self, planar: usize) {
        let offset = planar * VGA_planar_writer::PLANE_SZ;
        for i in 0..VGA_planar_writer::PLANE_SZ {
            qemu_print_num(self.plane_buffer[i + offset] as u64);
        }
    }

    pub fn present(&mut self, frame_nr: u32) {
        qemu_fmt_println("{}", format_args!("Presenting frame: {}", frame_nr));
        self.replicate();
        //self.plane.restore();
    }

    fn clear_screen(&mut self) {
        self.reset_ext_memory();
    }

    pub fn fill_screen(&mut self, color: ColorCode) {
        for k in 0..4 {
            let bit = (color as u8) & (1 << k);
            let mut fill_val = if (bit > 0) { 255 } else { 0 };
            unsafe {
                let ptr = self
                    .plane_buffer
                    .as_mut_ptr()
                    .add(k * VGA_planar_writer::PLANE_SZ);
                let mut slice = core::slice::from_raw_parts_mut(ptr, VGA_planar_writer::PLANE_SZ);
                slice.fill(fill_val);
            }
        }
    }

    pub fn color_test(&mut self) {
        self.palette
            .update_color_entry(0, CustomColor::new(63, 0, 0));
        qemu_print("TEST!\n");

        self.palette.update_vga_dac_state();
    }

    pub fn restore(&mut self) {
        self.plane.restore();
    }
}
